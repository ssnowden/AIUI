"""project_apps.models.models.py

Description of the models.

class AIModel(models.Model)
    id: uuid.UUID
    name: str
    description: str
    access_mode: str
    access_endpoint: str
    token_cost_per_1M_input: float
    token_cost_per_1M_output: float
    best_use_cases: str
    max_tokens: int
    is_active: bool

    created_by: "get_user_model()"
    created_at: "datetime.date"
    modified_by: "get_user_model()"
    modified_at: "datetime.date"

"""

import uuid

from django.conf import settings
from django.contrib.auth import get_user_model
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _
from openai import OpenAI


class AIModel(models.Model):
    ACCESS_MODE_OPENAI_API: str = "openai_api"
    ACCESS_MODE_LOCAL: str = "local"
    ACCESS_MODE_TRANSFORMER: str = "transformer"

    ACCESS_MODE_CHOICES: tuple = (
        (ACCESS_MODE_OPENAI_API, _("OpenAI API")),
        (ACCESS_MODE_LOCAL, _("Local Access")),
        (ACCESS_MODE_TRANSFORMER, _("Transformer Library")),
    )

    id: uuid.UUID = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False,
    )
    name: str = models.CharField(
        max_length=150,
        unique=True,
        verbose_name=_("AI Model Name"),
    )
    description: str = models.TextField(
        blank=True, null=True, verbose_name="AI Model Description"
    )
    access_mode: str = models.CharField(
        max_length=50,
        choices=ACCESS_MODE_CHOICES,
        default=ACCESS_MODE_OPENAI_API,
        verbose_name=_("Access Mode"),
    )
    access_endpoint: str = models.URLField(
        max_length=300,
        blank=True,
        verbose_name=_("Access Endpoint"),
        help_text=_("API or service endpoint for accessing the model."),
    )
    token_cost_per_1M_input: float = models.DecimalField(
        max_digits=8,
        decimal_places=4,
        default=0.0,
        verbose_name=_("Token Cost per 1M Input"),
        help_text=_("Cost per 1 million tokens input (USD or other currency)."),
    )
    token_cost_per_1M_output: float = models.DecimalField(
        max_digits=8,
        decimal_places=4,
        default=0.0,
        verbose_name=_("Token Cost per 1M Output"),
        help_text=_("Cost per 1 million tokens output (USD or other currency)."),
    )
    best_use_cases: str = models.TextField(
        blank=True,
        verbose_name=_("Best Use Cases"),
        help_text=_("Recommended use cases for this model."),
    )
    max_tokens: int = models.PositiveIntegerField(
        default=4096,
        verbose_name=_("Max Tokens"),
        help_text=_("Maximum tokens supported by the model."),
    )
    is_active: bool = models.BooleanField(
        default=True,
        verbose_name=_("Is Active"),
        help_text=_("Is this model currently available for use?"),
    )

    created_by: "get_user_model()" = models.ForeignKey(
        get_user_model(),
        on_delete=models.SET_NULL,
        null=True,
        related_name="created_ai_models",
        verbose_name=_("AI Model Created By"),
    )
    created_at: "datetime.date" = models.DateField(
        auto_now_add=True, verbose_name="AI Model Created At"
    )
    modified_by: "get_user_model()" = models.ForeignKey(
        get_user_model(),
        on_delete=models.SET_NULL,
        null=True,
        related_name="modified_ai_models",
        verbose_name=_("AI Model Modified By"),
    )
    modified_at: "datetime.date" = models.DateField(
        auto_now=True, verbose_name="AI Model Modified At"
    )

    class Meta:

        verbose_name: str = _("AI Model")
        verbose_name_plural: str = _("AI Models")
        ordering = ["name"]

    def __str__(self) -> str:
        """Returns the string representation of the AI model.

        Returns:
            str: The name of the AI model.
        """
        return self.name

    def get_absolute_url(self) -> str:
        """Returns the absolute URL for the AI model detail view.

        Returns:
            str: The URL for the AI model detail page.
        """
        return reverse("aimodel_detail", args=[self.id])

    def get_aimodel_response(self, prompt: str) -> str:
        """Gets a response from the AI model based on the provided prompt.

        This method routes the prompt to the appropriate backend based on the model's access mode.
        It supports OpenAI API, local inference, OpenRouter, and native API endpoints.

        Args:
            prompt (str): The input prompt to send to the AI model.

        Returns:
            str: The response generated by the AI model.
        """
        if self.access_mode == self.ACCESS_MODE_OPENAI_API:
            # Here you would integrate with the OpenAI API using the access_endpoint
            client = OpenAI(
                base_url=self.access_endpoint,
                api_key=settings.OPEN_AI_MODEL_KEY,
            )

            return client.chat.completions.create(
                # extra_headers={
                #     "HTTP-Referer": "<YOUR_SITE_URL>",  # Optional. Site URL for rankings on openrouter.ai.
                #     "X-Title": "<YOUR_SITE_NAME>",  # Optional. Site title for rankings on openrouter.ai.
                # },
                extra_body={},
                model="openai/gpt-oss-20b:free",
                messages=[{"role": "user", "content": prompt.strip()}],
            )
        elif self.access_mode == self.ACCESS_MODE_LOCAL:
            # Here you would integrate with a local model inference (e.g. ollama)
            return f"Response from Local Model for prompt: {prompt.strip()}"
        elif self.access_mode == self.ACCESS_MODE_TRANSFORMER:
            # Here you would integrate with the transformer library
            return f"Response from OpenRouter for prompt: {prompt.strip()}"
        else:
            return f"Echo: {prompt.strip()}"

    """
    Hook for doing any extra model-wide validation after clean() has been
    called on every field by self.clean_fields. Any ValidationError raised
    by this method will not be associated with a particular field; it will
    have a special-case association with the field defined by NON_FIELD_ERRORS.
    e.g.
    
    def clean(self, *args, **kwargs):
        if self.__original_is_company_invite != self.is_company_invite:
            raise ValidationError(_("is_company_invite cannot be changed."))

        if self.__original_company != self.company:
            raise ValidationError(_("company for invite cannot be changed."))

        if self.__original_is_venue_invite != self.is_venue_invite:
            raise ValidationError(_("is_venue_invite cannot be changed."))

        if self.is_company_invite and self.is_venue_invite:
            raise ValidationError(
                _("An invite cannot be both a company and venue invite.")
            )

        if not self.is_company_invite and not self.is_venue_invite:
            raise ValidationError(
                _("An invite must be either a company or a venue invite.")
            )

        if self.is_company_invite and not self.company:
            raise ObjectDoesNotExist(
                _("An invite for a company must have a company specified.")
            )

        if self.is_venue_invite and self.company:
            raise ValidationError(
                _("An invite for a venue shouldn't have a company specified.")
            )

        if self.company:
            company_id = self.company.id
            company_for_permissions_test = Company.objects.get(id=company_id)
            company_user_profiles = company_for_permissions_test.usercompanies.all()
            company_users = [user_profile.user for user_profile in company_user_profiles]

            if self.created_by not in company_users:
                raise ValidationError(
                    _(
                        "An invite for a company cannot be created by a user not a member of that company."
                    )
                )
    """
